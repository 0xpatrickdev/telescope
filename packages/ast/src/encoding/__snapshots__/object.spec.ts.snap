// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`cosmos/tx/signing/v1beta1/signing SignatureDescriptor 1`] = `
"export const SignatureDescriptor = {
  encode(message: SignatureDescriptor, writer = _m0.Writer.create()): _m0.Writer {
    if (message.publicKey !== undefined) {
      Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
    }

    if (message.data !== undefined) {
      SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
    }

    if (!message.sequence.isZero()) {
      writer.uint32(24).uint64(message.sequence);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureDescriptor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureDescriptor();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.publicKey = Any.decode(reader, reader.uint32());
          break;

        case 2:
          message.data = SignatureDescriptor_Data.decode(reader, reader.uint32());
          break;

        case 3:
          message.sequence = (reader.uint64() as Long);
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): SignatureDescriptor {
    return {
      publicKey: isSet(object.publicKey) ? Any.fromJSON(object.publicKey) : undefined,
      data: isSet(object.data) ? SignatureDescriptor_Data.fromJSON(object.data) : undefined,
      sequence: isSet(object.sequence) ? Long.fromString(object.sequence) : Long.UZERO
    };
  },

  toJSON(message: SignatureDescriptor): unknown {
    const obj: any = {};
    message.publicKey !== undefined && (obj.publicKey = message.publicKey ? Any.toJSON(message.publicKey) : undefined);
    message.data !== undefined && (obj.data = message.data ? SignatureDescriptor_Data.toJSON(message.data) : undefined);
    message.sequence !== undefined && (obj.sequence = (message.sequence || Long.UZERO).toString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SignatureDescriptor>, I>>(object: I): SignatureDescriptor {
    const message = createBaseSignatureDescriptor();
    message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? Any.fromPartial(object.publicKey) : undefined;
    message.data = object.data !== undefined && object.data !== null ? SignatureDescriptor_Data.fromPartial(object.data) : undefined;
    message.sequence = object.sequence !== undefined && object.sequence !== null ? Long.fromValue(object.sequence) : Long.UZERO;
    return message;
  }

};"
`;

exports[`cosmos/tx/signing/v1beta1/signing SignatureDescriptors 1`] = `
"export const SignatureDescriptors = {
  encode(message: SignatureDescriptors, writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signatures) {
      SignatureDescriptor.encode(v!, writer.uint32(10).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignatureDescriptors {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureDescriptors();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.signatures.push(SignatureDescriptor.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): SignatureDescriptors {
    return {
      signatures: Array.isArray(object?.signatures) ? object.signatures.map((e: any) => SignatureDescriptor.fromJSON(e)) : []
    };
  },

  toJSON(message: SignatureDescriptors): unknown {
    const obj: any = {};

    if (message.signatures) {
      obj.signatures = message.signatures.map(e => e ? SignatureDescriptor.toJSON(e) : undefined);
    } else {
      obj.signatures = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SignatureDescriptors>, I>>(object: I): SignatureDescriptors {
    const message = createBaseSignatureDescriptors();
    message.signatures = object.signatures?.map(e => SignatureDescriptor.fromPartial(e)) || [];
    return message;
  }

};"
`;

exports[`cosmos/tx/v1beta1/tx AuxSignerData 1`] = `
"export const AuxSignerData = {
  encode(message: AuxSignerData, writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== \\"\\") {
      writer.uint32(10).string(message.address);
    }

    if (message.signDoc !== undefined) {
      SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
    }

    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }

    if (message.sig.length !== 0) {
      writer.uint32(34).bytes(message.sig);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuxSignerData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuxSignerData();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;

        case 2:
          message.signDoc = SignDocDirectAux.decode(reader, reader.uint32());
          break;

        case 3:
          message.mode = (reader.int32() as any);
          break;

        case 4:
          message.sig = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): AuxSignerData {
    return {
      address: isSet(object.address) ? String(object.address) : \\"\\",
      signDoc: isSet(object.signDoc) ? SignDocDirectAux.fromJSON(object.signDoc) : undefined,
      mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,
      sig: isSet(object.sig) ? bytesFromBase64(object.sig) : new Uint8Array()
    };
  },

  toJSON(message: AuxSignerData): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    message.signDoc !== undefined && (obj.signDoc = message.signDoc ? SignDocDirectAux.toJSON(message.signDoc) : undefined);
    message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));
    message.sig !== undefined && (obj.sig = base64FromBytes(message.sig !== undefined ? message.sig : new Uint8Array()));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AuxSignerData>, I>>(object: I): AuxSignerData {
    const message = createBaseAuxSignerData();
    message.address = object.address ?? \\"\\";
    message.signDoc = object.signDoc !== undefined && object.signDoc !== null ? SignDocDirectAux.fromPartial(object.signDoc) : undefined;
    message.mode = object.mode ?? 0;
    message.sig = object.sig ?? new Uint8Array();
    return message;
  }

};"
`;

exports[`cosmos/tx/v1beta1/tx ModeInfo_Multi 1`] = `
"export const ModeInfo_Multi = {
  encode(message: ModeInfo_Multi, writer = _m0.Writer.create()): _m0.Writer {
    if (message.single !== undefined) {
      ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
    }

    if (message.multi !== undefined) {
      ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModeInfo_Multi {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModeInfo_Multi();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.single = ModeInfo_Single.decode(reader, reader.uint32());
          break;

        case 2:
          message.multi = ModeInfo_Multi.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): ModeInfo_Multi {
    return {
      single: isSet(object.single) ? ModeInfo_Single.fromJSON(object.single) : undefined,
      multi: isSet(object.multi) ? ModeInfo_Multi.fromJSON(object.multi) : undefined
    };
  },

  toJSON(message: ModeInfo_Multi): unknown {
    const obj: any = {};
    message.single !== undefined && (obj.single = message.single ? ModeInfo_Single.toJSON(message.single) : undefined);
    message.multi !== undefined && (obj.multi = message.multi ? ModeInfo_Multi.toJSON(message.multi) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ModeInfo_Multi>, I>>(object: I): ModeInfo_Multi {
    const message = createBaseModeInfo_Multi();
    message.single = object.single !== undefined && object.single !== null ? ModeInfo_Single.fromPartial(object.single) : undefined;
    message.multi = object.multi !== undefined && object.multi !== null ? ModeInfo_Multi.fromPartial(object.multi) : undefined;
    return message;
  }

};"
`;

exports[`cosmwasm/wasm/v1/proposal 1`] = `
"export const PinCodesProposal = {
  encode(message: PinCodesProposal, writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== \\"\\") {
      writer.uint32(10).string(message.title);
    }

    if (message.description !== \\"\\") {
      writer.uint32(18).string(message.description);
    }

    writer.uint32(24).fork();

    for (const v of message.codeIds) {
      writer.uint64(v);
    }

    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PinCodesProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinCodesProposal();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;

        case 2:
          message.description = reader.string();
          break;

        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;

            while (reader.pos < end2) {
              message.codeIds.push((reader.uint64() as Long));
            }
          } else {
            message.codeIds.push((reader.uint64() as Long));
          }

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): PinCodesProposal {
    return {
      title: isSet(object.title) ? String(object.title) : \\"\\",
      description: isSet(object.description) ? String(object.description) : \\"\\",
      codeIds: Array.isArray(object?.codeIds) ? object.codeIds.map((e: any) => Long.fromString(e)) : []
    };
  },

  toJSON(message: PinCodesProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);

    if (message.codeIds) {
      obj.codeIds = message.codeIds.map(e => (e || Long.UZERO).toString());
    } else {
      obj.codeIds = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PinCodesProposal>, I>>(object: I): PinCodesProposal {
    const message = createBasePinCodesProposal();
    message.title = object.title ?? \\"\\";
    message.description = object.description ?? \\"\\";
    message.codeIds = object.codeIds?.map(e => Long.fromValue(e)) || [];
    return message;
  }

};"
`;

exports[`cosmwasm/wasm/v1/proposal 2`] = `
"export const UnpinCodesProposal = {
  encode(message: UnpinCodesProposal, writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== \\"\\") {
      writer.uint32(10).string(message.title);
    }

    if (message.description !== \\"\\") {
      writer.uint32(18).string(message.description);
    }

    writer.uint32(24).fork();

    for (const v of message.codeIds) {
      writer.uint64(v);
    }

    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnpinCodesProposal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnpinCodesProposal();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;

        case 2:
          message.description = reader.string();
          break;

        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;

            while (reader.pos < end2) {
              message.codeIds.push((reader.uint64() as Long));
            }
          } else {
            message.codeIds.push((reader.uint64() as Long));
          }

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): UnpinCodesProposal {
    return {
      title: isSet(object.title) ? String(object.title) : \\"\\",
      description: isSet(object.description) ? String(object.description) : \\"\\",
      codeIds: Array.isArray(object?.codeIds) ? object.codeIds.map((e: any) => Long.fromString(e)) : []
    };
  },

  toJSON(message: UnpinCodesProposal): unknown {
    const obj: any = {};
    message.title !== undefined && (obj.title = message.title);
    message.description !== undefined && (obj.description = message.description);

    if (message.codeIds) {
      obj.codeIds = message.codeIds.map(e => (e || Long.UZERO).toString());
    } else {
      obj.codeIds = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnpinCodesProposal>, I>>(object: I): UnpinCodesProposal {
    const message = createBaseUnpinCodesProposal();
    message.title = object.title ?? \\"\\";
    message.description = object.description ?? \\"\\";
    message.codeIds = object.codeIds?.map(e => Long.fromValue(e)) || [];
    return message;
  }

};"
`;

exports[`cosmwasm/wasm/v1/query 1`] = `
"export const QueryRawContractStateRequest = {
  encode(message: QueryRawContractStateRequest, writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== \\"\\") {
      writer.uint32(10).string(message.address);
    }

    if (message.queryData.length !== 0) {
      writer.uint32(18).bytes(message.queryData);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRawContractStateRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRawContractStateRequest();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;

        case 2:
          message.queryData = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): QueryRawContractStateRequest {
    return {
      address: isSet(object.address) ? String(object.address) : \\"\\",
      queryData: isSet(object.queryData) ? bytesFromBase64(object.queryData) : new Uint8Array()
    };
  },

  toJSON(message: QueryRawContractStateRequest): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    message.queryData !== undefined && (obj.queryData = base64FromBytes(message.queryData !== undefined ? message.queryData : new Uint8Array()));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QueryRawContractStateRequest>, I>>(object: I): QueryRawContractStateRequest {
    const message = createBaseQueryRawContractStateRequest();
    message.address = object.address ?? \\"\\";
    message.queryData = object.queryData ?? new Uint8Array();
    return message;
  }

};"
`;

exports[`google/api/expr/conformance/v1alpha1/conformance_service ParseRequest 1`] = `
"export const ParseRequest = {
  encode(message: ParseRequest, writer = _m0.Writer.create()): _m0.Writer {
    if (message.celSource !== \\"\\") {
      writer.uint32(10).string(message.celSource);
    }

    if (message.syntaxVersion !== \\"\\") {
      writer.uint32(18).string(message.syntaxVersion);
    }

    if (message.sourceLocation !== \\"\\") {
      writer.uint32(26).string(message.sourceLocation);
    }

    if (message.disableMacros === true) {
      writer.uint32(32).bool(message.disableMacros);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ParseRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseRequest();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.celSource = reader.string();
          break;

        case 2:
          message.syntaxVersion = reader.string();
          break;

        case 3:
          message.sourceLocation = reader.string();
          break;

        case 4:
          message.disableMacros = reader.bool();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): ParseRequest {
    return {
      celSource: isSet(object.celSource) ? String(object.celSource) : \\"\\",
      syntaxVersion: isSet(object.syntaxVersion) ? String(object.syntaxVersion) : \\"\\",
      sourceLocation: isSet(object.sourceLocation) ? String(object.sourceLocation) : \\"\\",
      disableMacros: isSet(object.disableMacros) ? Boolean(object.disableMacros) : false
    };
  },

  toJSON(message: ParseRequest): unknown {
    const obj: any = {};
    message.celSource !== undefined && (obj.celSource = message.celSource);
    message.syntaxVersion !== undefined && (obj.syntaxVersion = message.syntaxVersion);
    message.sourceLocation !== undefined && (obj.sourceLocation = message.sourceLocation);
    message.disableMacros !== undefined && (obj.disableMacros = message.disableMacros);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ParseRequest>, I>>(object: I): ParseRequest {
    const message = createBaseParseRequest();
    message.celSource = object.celSource ?? \\"\\";
    message.syntaxVersion = object.syntaxVersion ?? \\"\\";
    message.sourceLocation = object.sourceLocation ?? \\"\\";
    message.disableMacros = object.disableMacros ?? false;
    return message;
  }

};"
`;

exports[`google/api/expr/v1alpha1/checked Decl_FunctionDecl_Overload MapType 1`] = `
"export const Decl_FunctionDecl_Overload = {
  encode(message: Decl_FunctionDecl_Overload, writer = _m0.Writer.create()): _m0.Writer {
    if (message.overloadId !== \\"\\") {
      writer.uint32(10).string(message.overloadId);
    }

    for (const v of message.params) {
      Type.encode(v!, writer.uint32(18).fork()).ldelim();
    }

    for (const v of message.typeParams) {
      writer.uint32(26).string(v!);
    }

    if (message.resultType !== undefined) {
      Type.encode(message.resultType, writer.uint32(34).fork()).ldelim();
    }

    if (message.isInstanceFunction === true) {
      writer.uint32(40).bool(message.isInstanceFunction);
    }

    if (message.doc !== \\"\\") {
      writer.uint32(50).string(message.doc);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Decl_FunctionDecl_Overload {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecl_FunctionDecl_Overload();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.overloadId = reader.string();
          break;

        case 2:
          message.params.push(Type.decode(reader, reader.uint32()));
          break;

        case 3:
          message.typeParams.push(reader.string());

        case 4:
          message.resultType = Type.decode(reader, reader.uint32());
          break;

        case 5:
          message.isInstanceFunction = reader.bool();
          break;

        case 6:
          message.doc = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): Decl_FunctionDecl_Overload {
    return {
      overloadId: isSet(object.overloadId) ? String(object.overloadId) : \\"\\",
      params: Array.isArray(object?.params) ? object.params.map((e: any) => Type.fromJSON(e)) : [],
      typeParams: Array.isArray(object?.typeParams) ? object.typeParams.map((e: any) => String(e)) : [],
      resultType: isSet(object.resultType) ? Type.fromJSON(object.resultType) : undefined,
      isInstanceFunction: isSet(object.isInstanceFunction) ? Boolean(object.isInstanceFunction) : false,
      doc: isSet(object.doc) ? String(object.doc) : \\"\\"
    };
  },

  toJSON(message: Decl_FunctionDecl_Overload): unknown {
    const obj: any = {};
    message.overloadId !== undefined && (obj.overloadId = message.overloadId);

    if (message.params) {
      obj.params = message.params.map(e => e ? Type.toJSON(e) : undefined);
    } else {
      obj.params = [];
    }

    if (message.typeParams) {
      obj.typeParams = message.typeParams.map(e => e);
    } else {
      obj.typeParams = [];
    }

    message.resultType !== undefined && (obj.resultType = message.resultType ? Type.toJSON(message.resultType) : undefined);
    message.isInstanceFunction !== undefined && (obj.isInstanceFunction = message.isInstanceFunction);
    message.doc !== undefined && (obj.doc = message.doc);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Decl_FunctionDecl_Overload>, I>>(object: I): Decl_FunctionDecl_Overload {
    const message = createBaseDecl_FunctionDecl_Overload();
    message.overloadId = object.overloadId ?? \\"\\";
    message.params = object.params?.map(e => Type.fromPartial(e)) || [];
    message.typeParams = object.typeParams?.map(e => e) || [];
    message.resultType = object.resultType !== undefined && object.resultType !== null ? Type.fromPartial(object.resultType) : undefined;
    message.isInstanceFunction = object.isInstanceFunction ?? false;
    message.doc = object.doc ?? \\"\\";
    return message;
  }

};"
`;

exports[`google/api/expr/v1alpha1/checked Type 1`] = `
"export const Type = {
  encode(message: Type, writer = _m0.Writer.create()): _m0.Writer {
    if (message.dyn !== undefined) {
      Empty.encode(message.dyn, writer.uint32(10).fork()).ldelim();
    }

    if (message.null !== undefined) {
      writer.uint32(16).int32(message.null);
    }

    if (message.primitive !== undefined) {
      writer.uint32(24).int32(message.primitive);
    }

    if (message.wrapper !== undefined) {
      writer.uint32(32).int32(message.wrapper);
    }

    if (message.wellKnown !== undefined) {
      writer.uint32(40).int32(message.wellKnown);
    }

    if (message.listType !== undefined) {
      Type_ListType.encode(message.listType, writer.uint32(50).fork()).ldelim();
    }

    if (message.mapType !== undefined) {
      Type_MapType.encode(message.mapType, writer.uint32(58).fork()).ldelim();
    }

    if (message.function !== undefined) {
      Type_FunctionType.encode(message.function, writer.uint32(66).fork()).ldelim();
    }

    if (message.messageType !== undefined) {
      writer.uint32(74).string(message.messageType);
    }

    if (message.typeParam !== undefined) {
      writer.uint32(82).string(message.typeParam);
    }

    if (message.type !== undefined) {
      Type.encode(message.type, writer.uint32(90).fork()).ldelim();
    }

    if (message.error !== undefined) {
      Empty.encode(message.error, writer.uint32(98).fork()).ldelim();
    }

    if (message.abstractType !== undefined) {
      Type_AbstractType.encode(message.abstractType, writer.uint32(114).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Type {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.dyn = Empty.decode(reader, reader.uint32());
          break;

        case 2:
          message.null = (reader.int32() as any);
          break;

        case 3:
          message.primitive = (reader.int32() as any);
          break;

        case 4:
          message.wrapper = (reader.int32() as any);
          break;

        case 5:
          message.wellKnown = (reader.int32() as any);
          break;

        case 6:
          message.listType = Type_ListType.decode(reader, reader.uint32());
          break;

        case 7:
          message.mapType = Type_MapType.decode(reader, reader.uint32());
          break;

        case 8:
          message.function = Type_FunctionType.decode(reader, reader.uint32());
          break;

        case 9:
          message.messageType = reader.string();
          break;

        case 10:
          message.typeParam = reader.string();
          break;

        case 11:
          message.type = Type.decode(reader, reader.uint32());
          break;

        case 12:
          message.error = Empty.decode(reader, reader.uint32());
          break;

        case 14:
          message.abstractType = Type_AbstractType.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): Type {
    return {
      dyn: isSet(object.dyn) ? Empty.fromJSON(object.dyn) : undefined,
      null: isSet(object.null) ? nullValueFromJSON(object.null) : 0,
      primitive: isSet(object.primitive) ? type_PrimitiveTypeFromJSON(object.primitive) : 0,
      wrapper: isSet(object.wrapper) ? type_PrimitiveTypeFromJSON(object.wrapper) : 0,
      wellKnown: isSet(object.wellKnown) ? type_WellKnownTypeFromJSON(object.wellKnown) : 0,
      listType: isSet(object.listType) ? Type_ListType.fromJSON(object.listType) : undefined,
      mapType: isSet(object.mapType) ? Type_MapType.fromJSON(object.mapType) : undefined,
      function: isSet(object.function) ? Type_FunctionType.fromJSON(object.function) : undefined,
      messageType: isSet(object.messageType) ? String(object.messageType) : \\"\\",
      typeParam: isSet(object.typeParam) ? String(object.typeParam) : \\"\\",
      type: isSet(object.type) ? Type.fromJSON(object.type) : undefined,
      error: isSet(object.error) ? Empty.fromJSON(object.error) : undefined,
      abstractType: isSet(object.abstractType) ? Type_AbstractType.fromJSON(object.abstractType) : undefined
    };
  },

  toJSON(message: Type): unknown {
    const obj: any = {};
    message.dyn !== undefined && (obj.dyn = message.dyn ? Empty.toJSON(message.dyn) : undefined);
    message.null !== undefined && (obj.null = nullValueToJSON(message.null));
    message.primitive !== undefined && (obj.primitive = type_PrimitiveTypeToJSON(message.primitive));
    message.wrapper !== undefined && (obj.wrapper = type_PrimitiveTypeToJSON(message.wrapper));
    message.wellKnown !== undefined && (obj.wellKnown = type_WellKnownTypeToJSON(message.wellKnown));
    message.listType !== undefined && (obj.listType = message.listType ? Type_ListType.toJSON(message.listType) : undefined);
    message.mapType !== undefined && (obj.mapType = message.mapType ? Type_MapType.toJSON(message.mapType) : undefined);
    message.function !== undefined && (obj.function = message.function ? Type_FunctionType.toJSON(message.function) : undefined);
    message.messageType !== undefined && (obj.messageType = message.messageType);
    message.typeParam !== undefined && (obj.typeParam = message.typeParam);
    message.type !== undefined && (obj.type = message.type ? Type.toJSON(message.type) : undefined);
    message.error !== undefined && (obj.error = message.error ? Empty.toJSON(message.error) : undefined);
    message.abstractType !== undefined && (obj.abstractType = message.abstractType ? Type_AbstractType.toJSON(message.abstractType) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Type>, I>>(object: I): Type {
    const message = createBaseType();
    message.dyn = object.dyn !== undefined && object.dyn !== null ? Empty.fromPartial(object.dyn) : undefined;
    message.null = object.null ?? 0;
    message.primitive = object.primitive ?? 0;
    message.wrapper = object.wrapper ?? 0;
    message.wellKnown = object.wellKnown ?? 0;
    message.listType = object.listType !== undefined && object.listType !== null ? Type_ListType.fromPartial(object.listType) : undefined;
    message.mapType = object.mapType !== undefined && object.mapType !== null ? Type_MapType.fromPartial(object.mapType) : undefined;
    message.function = object.function !== undefined && object.function !== null ? Type_FunctionType.fromPartial(object.function) : undefined;
    message.messageType = object.messageType ?? \\"\\";
    message.typeParam = object.typeParam ?? \\"\\";
    message.type = object.type !== undefined && object.type !== null ? Type.fromPartial(object.type) : undefined;
    message.error = object.error !== undefined && object.error !== null ? Empty.fromPartial(object.error) : undefined;
    message.abstractType = object.abstractType !== undefined && object.abstractType !== null ? Type_AbstractType.fromPartial(object.abstractType) : undefined;
    return message;
  }

};"
`;

exports[`google/api/expr/v1alpha1/checked nested MapType 1`] = `
"export const Type_MapType = {
  encode(message: Type_MapType, writer = _m0.Writer.create()): _m0.Writer {
    if (message.keyType !== undefined) {
      Type.encode(message.keyType, writer.uint32(10).fork()).ldelim();
    }

    if (message.valueType !== undefined) {
      Type.encode(message.valueType, writer.uint32(18).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Type_MapType {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseType_MapType();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.keyType = Type.decode(reader, reader.uint32());
          break;

        case 2:
          message.valueType = Type.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): Type_MapType {
    return {
      keyType: isSet(object.keyType) ? Type.fromJSON(object.keyType) : undefined,
      valueType: isSet(object.valueType) ? Type.fromJSON(object.valueType) : undefined
    };
  },

  toJSON(message: Type_MapType): unknown {
    const obj: any = {};
    message.keyType !== undefined && (obj.keyType = message.keyType ? Type.toJSON(message.keyType) : undefined);
    message.valueType !== undefined && (obj.valueType = message.valueType ? Type.toJSON(message.valueType) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Type_MapType>, I>>(object: I): Type_MapType {
    const message = createBaseType_MapType();
    message.keyType = object.keyType !== undefined && object.keyType !== null ? Type.fromPartial(object.keyType) : undefined;
    message.valueType = object.valueType !== undefined && object.valueType !== null ? Type.fromPartial(object.valueType) : undefined;
    return message;
  }

};"
`;

exports[`google/api/expr/v1alpha1/checked typeHash (Long) CheckedExpr 1`] = `
"export const CheckedExpr = {
  encode(message: CheckedExpr, writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.referenceMap).forEach(([key, value]) => {
      CheckedExpr_ReferenceMapEntry.encode({
        key: (key as any),
        value
      }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.typeMap).forEach(([key, value]) => {
      CheckedExpr_TypeMapEntry.encode({
        key: (key as any),
        value
      }, writer.uint32(26).fork()).ldelim();
    });

    if (message.sourceInfo !== undefined) {
      SourceInfo.encode(message.sourceInfo, writer.uint32(42).fork()).ldelim();
    }

    if (message.exprVersion !== \\"\\") {
      writer.uint32(50).string(message.exprVersion);
    }

    if (message.expr !== undefined) {
      Expr.encode(message.expr, writer.uint32(34).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckedExpr {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckedExpr();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 2:
          const entry2 = CheckedExpr_ReferenceMapEntry.decode(reader, reader.uint32());

          if (entry2.value !== undefined) {
            message.referenceMap[entry2.key] = entry2.value;
          }

          break;

        case 3:
          const entry3 = CheckedExpr_TypeMapEntry.decode(reader, reader.uint32());

          if (entry3.value !== undefined) {
            message.typeMap[entry3.key] = entry3.value;
          }

          break;

        case 5:
          message.sourceInfo = SourceInfo.decode(reader, reader.uint32());
          break;

        case 6:
          message.exprVersion = reader.string();
          break;

        case 4:
          message.expr = Expr.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): CheckedExpr {
    return {
      referenceMap: isObject(object.referenceMap) ? Object.entries(object.referenceMap).reduce<{
        [key: Long]: Reference;
      }>((acc, [key, value]) => {
        acc[Number(key)] = Reference.fromJSON(value);
        return acc;
      }, {}) : {},
      typeMap: isObject(object.typeMap) ? Object.entries(object.typeMap).reduce<{
        [key: Long]: Type;
      }>((acc, [key, value]) => {
        acc[Number(key)] = Type.fromJSON(value);
        return acc;
      }, {}) : {},
      sourceInfo: isSet(object.sourceInfo) ? SourceInfo.fromJSON(object.sourceInfo) : undefined,
      exprVersion: isSet(object.exprVersion) ? String(object.exprVersion) : \\"\\",
      expr: isSet(object.expr) ? Expr.fromJSON(object.expr) : undefined
    };
  },

  toJSON(message: CheckedExpr): unknown {
    const obj: any = {};
    obj.referenceMap = {};

    if (message.referenceMap) {
      Object.entries(message.referenceMap).forEach(([k, v]) => {
        obj.referenceMap[k] = Reference.toJSON(v);
      });
    }

    obj.typeMap = {};

    if (message.typeMap) {
      Object.entries(message.typeMap).forEach(([k, v]) => {
        obj.typeMap[k] = Type.toJSON(v);
      });
    }

    message.sourceInfo !== undefined && (obj.sourceInfo = message.sourceInfo ? SourceInfo.toJSON(message.sourceInfo) : undefined);
    message.exprVersion !== undefined && (obj.exprVersion = message.exprVersion);
    message.expr !== undefined && (obj.expr = message.expr ? Expr.toJSON(message.expr) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CheckedExpr>, I>>(object: I): CheckedExpr {
    const message = createBaseCheckedExpr();
    message.referenceMap = Object.entries(object.referenceMap ?? {}).reduce<{
      [key: Long]: Reference;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[Number(key)] = Reference.fromPartial(value);
      }

      return acc;
    }, {});
    message.typeMap = Object.entries(object.typeMap ?? {}).reduce<{
      [key: Long]: Type;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[Number(key)] = Type.fromPartial(value);
      }

      return acc;
    }, {});
    message.sourceInfo = object.sourceInfo !== undefined && object.sourceInfo !== null ? SourceInfo.fromPartial(object.sourceInfo) : undefined;
    message.exprVersion = object.exprVersion ?? \\"\\";
    message.expr = object.expr !== undefined && object.expr !== null ? Expr.fromPartial(object.expr) : undefined;
    return message;
  }

};"
`;

exports[`google/api/expr/v1alpha1/syntax Constant 1`] = `
"export const Constant = {
  encode(message: Constant, writer = _m0.Writer.create()): _m0.Writer {
    if (message.nullValue !== undefined) {
      writer.uint32(8).int32(message.nullValue);
    }

    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue);
    }

    if (message.int64Value !== undefined) {
      writer.uint32(24).int64(message.int64Value);
    }

    if (message.uint64Value !== undefined) {
      writer.uint32(32).uint64(message.uint64Value);
    }

    if (message.doubleValue !== undefined) {
      writer.uint32(41).double(message.doubleValue);
    }

    if (message.stringValue !== undefined) {
      writer.uint32(50).string(message.stringValue);
    }

    if (message.bytesValue !== undefined) {
      writer.uint32(58).bytes(message.bytesValue);
    }

    if (message.durationValue !== undefined) Duration.encode(toDuration(message.durationValue), writer.uint32(66).fork()).ldelim();
    if (message.timestampValue !== undefined) Timestamp.encode(toTimestamp(message.timestampValue), writer.uint32(74).fork()).ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Constant {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstant();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.nullValue = (reader.int32() as any);
          break;

        case 2:
          message.boolValue = reader.bool();
          break;

        case 3:
          message.int64Value = (reader.int64() as Long);
          break;

        case 4:
          message.uint64Value = (reader.uint64() as Long);
          break;

        case 5:
          message.doubleValue = reader.double();
          break;

        case 6:
          message.stringValue = reader.string();
          break;

        case 7:
          message.bytesValue = reader.bytes();
          break;

        case 8:
          message.durationValue = fromDuration(Duration.decode(reader, reader.uint32()));
          break;

        case 9:
          message.timestampValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): Constant {
    return {
      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : 0,
      boolValue: isSet(object.boolValue) ? Boolean(object.boolValue) : false,
      int64Value: isSet(object.int64Value) ? Long.fromString(object.int64Value) : Long.ZERO,
      uint64Value: isSet(object.uint64Value) ? Long.fromString(object.uint64Value) : Long.UZERO,
      doubleValue: isSet(object.doubleValue) ? Number(object.doubleValue) : 0,
      stringValue: isSet(object.stringValue) ? String(object.stringValue) : \\"\\",
      bytesValue: isSet(object.bytesValue) ? bytesFromBase64(object.bytesValue) : new Uint8Array(),
      durationValue: isSet(object.durationValue) ? String(object.durationValue) : undefined,
      timestampValue: isSet(object.timestampValue) ? fromJsonTimestamp(object.timestampValue) : undefined
    };
  },

  toJSON(message: Constant): unknown {
    const obj: any = {};
    message.nullValue !== undefined && (obj.nullValue = nullValueToJSON(message.nullValue));
    message.boolValue !== undefined && (obj.boolValue = message.boolValue);
    message.int64Value !== undefined && (obj.int64Value = (message.int64Value || Long.ZERO).toString());
    message.uint64Value !== undefined && (obj.uint64Value = (message.uint64Value || Long.UZERO).toString());
    message.doubleValue !== undefined && (obj.doubleValue = message.doubleValue);
    message.stringValue !== undefined && (obj.stringValue = message.stringValue);
    message.bytesValue !== undefined && (obj.bytesValue = base64FromBytes(message.bytesValue !== undefined ? message.bytesValue : new Uint8Array()));
    message.durationValue !== undefined && (obj.durationValue = message.durationValue);
    message.timestampValue !== undefined && (obj.timestampValue = message.timestampValue.toISOString());
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Constant>, I>>(object: I): Constant {
    const message = createBaseConstant();
    message.nullValue = object.nullValue ?? 0;
    message.boolValue = object.boolValue ?? false;
    message.int64Value = object.int64Value !== undefined && object.int64Value !== null ? Long.fromValue(object.int64Value) : Long.ZERO;
    message.uint64Value = object.uint64Value !== undefined && object.uint64Value !== null ? Long.fromValue(object.uint64Value) : Long.UZERO;
    message.doubleValue = object.doubleValue ?? 0;
    message.stringValue = object.stringValue ?? \\"\\";
    message.bytesValue = object.bytesValue ?? new Uint8Array();
    message.durationValue = object.durationValue ?? undefined;
    message.timestampValue = object.timestampValue ?? undefined;
    return message;
  }

};"
`;

exports[`google/api/expr/v1beta1/source 1`] = `
"export const SourceInfo = {
  encode(message: SourceInfo, writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== \\"\\") {
      writer.uint32(18).string(message.location);
    }

    writer.uint32(24).fork();

    for (const v of message.lineOffsets) {
      writer.int32(v);
    }

    writer.ldelim();
    Object.entries(message.positions).forEach(([key, value]) => {
      SourceInfo_PositionsEntry.encode({
        key: (key as any),
        value
      }, writer.uint32(32).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceInfo();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 2:
          message.location = reader.string();
          break;

        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;

            while (reader.pos < end2) {
              message.lineOffsets.push(reader.int32());
            }
          } else {
            message.lineOffsets.push(reader.int32());
          }

        case 4:
          const entry4 = SourceInfo_PositionsEntry.decode(reader, reader.uint32());

          if (entry4.value !== undefined) {
            message.positions[entry4.key] = entry4.value;
          }

          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): SourceInfo {
    return {
      location: isSet(object.location) ? String(object.location) : \\"\\",
      lineOffsets: Array.isArray(object?.lineOffsets) ? object.lineOffsets.map((e: any) => Number(e)) : [],
      positions: isObject(object.positions) ? Object.entries(object.positions).reduce<{
        [key: number]: number;
      }>((acc, [key, value]) => {
        acc[Number(key)] = Number(value);
        return acc;
      }, {}) : {}
    };
  },

  toJSON(message: SourceInfo): unknown {
    const obj: any = {};
    message.location !== undefined && (obj.location = message.location);

    if (message.lineOffsets) {
      obj.lineOffsets = message.lineOffsets.map(e => Math.round(e));
    } else {
      obj.lineOffsets = [];
    }

    obj.positions = {};

    if (message.positions) {
      Object.entries(message.positions).forEach(([k, v]) => {
        obj.positions[k] = Math.round(v);
      });
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SourceInfo>, I>>(object: I): SourceInfo {
    const message = createBaseSourceInfo();
    message.location = object.location ?? \\"\\";
    message.lineOffsets = object.lineOffsets?.map(e => e) || [];
    message.positions = Object.entries(object.positions ?? {}).reduce<{
      [key: number]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[Number(key)] = Number(value);
      }

      return acc;
    }, {});
    return message;
  }

};"
`;

exports[`google/api/quota keyType 1`] = `
"export const MetricRule = {
  encode(message: MetricRule, writer = _m0.Writer.create()): _m0.Writer {
    if (message.selector !== \\"\\") {
      writer.uint32(10).string(message.selector);
    }

    Object.entries(message.metricCosts).forEach(([key, value]) => {
      MetricRule_MetricCostsEntry.encode({
        key: (key as any),
        value
      }, writer.uint32(16).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricRule {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricRule();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.selector = reader.string();
          break;

        case 2:
          const entry2 = MetricRule_MetricCostsEntry.decode(reader, reader.uint32());

          if (entry2.value !== undefined) {
            message.metricCosts[entry2.key] = entry2.value;
          }

          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): MetricRule {
    return {
      selector: isSet(object.selector) ? String(object.selector) : \\"\\",
      metricCosts: isObject(object.metricCosts) ? Object.entries(object.metricCosts).reduce<{
        [key: string]: Long;
      }>((acc, [key, value]) => {
        acc[key] = Long.fromValue((value as Long | string));
        return acc;
      }, {}) : {}
    };
  },

  toJSON(message: MetricRule): unknown {
    const obj: any = {};
    message.selector !== undefined && (obj.selector = message.selector);
    obj.metricCosts = {};

    if (message.metricCosts) {
      Object.entries(message.metricCosts).forEach(([k, v]) => {
        obj.metricCosts[k] = v.toString();
      });
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MetricRule>, I>>(object: I): MetricRule {
    const message = createBaseMetricRule();
    message.selector = object.selector ?? \\"\\";
    message.metricCosts = Object.entries(object.metricCosts ?? {}).reduce<{
      [key: string]: Long;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }

      return acc;
    }, {});
    return message;
  }

};"
`;

exports[`google/api/quota keyType 2`] = `Array []`;

exports[`google/api/servicecontrol/v1/log_entry LogEntry 1`] = `
"export const LogEntry = {
  encode(message: LogEntry, writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== \\"\\") {
      writer.uint32(82).string(message.name);
    }

    if (message.timestamp !== undefined) Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(90).fork()).ldelim();

    if (message.severity !== 0) {
      writer.uint32(96).int32(message.severity);
    }

    if (message.httpRequest !== undefined) {
      HttpRequest.encode(message.httpRequest, writer.uint32(114).fork()).ldelim();
    }

    if (message.trace !== \\"\\") {
      writer.uint32(122).string(message.trace);
    }

    if (message.insertId !== \\"\\") {
      writer.uint32(34).string(message.insertId);
    }

    Object.entries(message.labels).forEach(([key, value]) => {
      LogEntry_LabelsEntry.encode({
        key: (key as any),
        value
      }, writer.uint32(106).fork()).ldelim();
    });

    if (message.protoPayload !== undefined) {
      Any.encode(message.protoPayload, writer.uint32(18).fork()).ldelim();
    }

    if (message.textPayload !== undefined) {
      writer.uint32(26).string(message.textPayload);
    }

    if (message.structPayload !== undefined) {
      Struct.encode(message.structPayload, writer.uint32(50).fork()).ldelim();
    }

    if (message.operation !== undefined) {
      LogEntryOperation.encode(message.operation, writer.uint32(130).fork()).ldelim();
    }

    if (message.sourceLocation !== undefined) {
      LogEntrySourceLocation.encode(message.sourceLocation, writer.uint32(138).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 10:
          message.name = reader.string();
          break;

        case 11:
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;

        case 12:
          message.severity = (reader.int32() as any);
          break;

        case 14:
          message.httpRequest = HttpRequest.decode(reader, reader.uint32());
          break;

        case 15:
          message.trace = reader.string();
          break;

        case 4:
          message.insertId = reader.string();
          break;

        case 13:
          const entry13 = LogEntry_LabelsEntry.decode(reader, reader.uint32());

          if (entry13.value !== undefined) {
            message.labels[entry13.key] = entry13.value;
          }

          break;

        case 2:
          message.protoPayload = Any.decode(reader, reader.uint32());
          break;

        case 3:
          message.textPayload = reader.string();
          break;

        case 6:
          message.structPayload = Struct.decode(reader, reader.uint32());
          break;

        case 16:
          message.operation = LogEntryOperation.decode(reader, reader.uint32());
          break;

        case 17:
          message.sourceLocation = LogEntrySourceLocation.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): LogEntry {
    return {
      name: isSet(object.name) ? String(object.name) : \\"\\",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      severity: isSet(object.severity) ? logSeverityFromJSON(object.severity) : 0,
      httpRequest: isSet(object.httpRequest) ? HttpRequest.fromJSON(object.httpRequest) : undefined,
      trace: isSet(object.trace) ? String(object.trace) : \\"\\",
      insertId: isSet(object.insertId) ? String(object.insertId) : \\"\\",
      labels: isObject(object.labels) ? Object.entries(object.labels).reduce<{
        [key: string]: string;
      }>((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      protoPayload: isSet(object.protoPayload) ? Any.fromJSON(object.protoPayload) : undefined,
      textPayload: isSet(object.textPayload) ? String(object.textPayload) : \\"\\",
      structPayload: isSet(object.structPayload) ? Struct.fromJSON(object.structPayload) : undefined,
      operation: isSet(object.operation) ? LogEntryOperation.fromJSON(object.operation) : undefined,
      sourceLocation: isSet(object.sourceLocation) ? LogEntrySourceLocation.fromJSON(object.sourceLocation) : undefined
    };
  },

  toJSON(message: LogEntry): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.timestamp !== undefined && (obj.timestamp = message.timestamp.toISOString());
    message.severity !== undefined && (obj.severity = logSeverityToJSON(message.severity));
    message.httpRequest !== undefined && (obj.httpRequest = message.httpRequest ? HttpRequest.toJSON(message.httpRequest) : undefined);
    message.trace !== undefined && (obj.trace = message.trace);
    message.insertId !== undefined && (obj.insertId = message.insertId);
    obj.labels = {};

    if (message.labels) {
      Object.entries(message.labels).forEach(([k, v]) => {
        obj.labels[k] = v;
      });
    }

    message.protoPayload !== undefined && (obj.protoPayload = message.protoPayload ? Any.toJSON(message.protoPayload) : undefined);
    message.textPayload !== undefined && (obj.textPayload = message.textPayload);
    message.structPayload !== undefined && (obj.structPayload = message.structPayload ? Struct.toJSON(message.structPayload) : undefined);
    message.operation !== undefined && (obj.operation = message.operation ? LogEntryOperation.toJSON(message.operation) : undefined);
    message.sourceLocation !== undefined && (obj.sourceLocation = message.sourceLocation ? LogEntrySourceLocation.toJSON(message.sourceLocation) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LogEntry>, I>>(object: I): LogEntry {
    const message = createBaseLogEntry();
    message.name = object.name ?? \\"\\";
    message.timestamp = object.timestamp ?? undefined;
    message.severity = object.severity ?? 0;
    message.httpRequest = object.httpRequest !== undefined && object.httpRequest !== null ? HttpRequest.fromPartial(object.httpRequest) : undefined;
    message.trace = object.trace ?? \\"\\";
    message.insertId = object.insertId ?? \\"\\";
    message.labels = Object.entries(object.labels ?? {}).reduce<{
      [key: string]: string;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = String(value);
      }

      return acc;
    }, {});
    message.protoPayload = object.protoPayload !== undefined && object.protoPayload !== null ? Any.fromPartial(object.protoPayload) : undefined;
    message.textPayload = object.textPayload ?? \\"\\";
    message.structPayload = object.structPayload !== undefined && object.structPayload !== null ? Struct.fromPartial(object.structPayload) : undefined;
    message.operation = object.operation !== undefined && object.operation !== null ? LogEntryOperation.fromPartial(object.operation) : undefined;
    message.sourceLocation = object.sourceLocation !== undefined && object.sourceLocation !== null ? LogEntrySourceLocation.fromPartial(object.sourceLocation) : undefined;
    return message;
  }

};"
`;

exports[`ibc/core/port/v1/query 1`] = `
"export const QueryAppVersionRequest = {
  encode(message: QueryAppVersionRequest, writer = _m0.Writer.create()): _m0.Writer {
    if (message.portId !== \\"\\") {
      writer.uint32(10).string(message.portId);
    }

    if (message.connectionId !== \\"\\") {
      writer.uint32(18).string(message.connectionId);
    }

    if (message.ordering !== 0) {
      writer.uint32(24).int32(message.ordering);
    }

    if (message.counterparty !== undefined) {
      Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
    }

    if (message.proposedVersion !== \\"\\") {
      writer.uint32(42).string(message.proposedVersion);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryAppVersionRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppVersionRequest();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.portId = reader.string();
          break;

        case 2:
          message.connectionId = reader.string();
          break;

        case 3:
          message.ordering = (reader.int32() as any);
          break;

        case 4:
          message.counterparty = Counterparty.decode(reader, reader.uint32());
          break;

        case 5:
          message.proposedVersion = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): QueryAppVersionRequest {
    return {
      portId: isSet(object.portId) ? String(object.portId) : \\"\\",
      connectionId: isSet(object.connectionId) ? String(object.connectionId) : \\"\\",
      ordering: isSet(object.ordering) ? orderFromJSON(object.ordering) : 0,
      counterparty: isSet(object.counterparty) ? Counterparty.fromJSON(object.counterparty) : undefined,
      proposedVersion: isSet(object.proposedVersion) ? String(object.proposedVersion) : \\"\\"
    };
  },

  toJSON(message: QueryAppVersionRequest): unknown {
    const obj: any = {};
    message.portId !== undefined && (obj.portId = message.portId);
    message.connectionId !== undefined && (obj.connectionId = message.connectionId);
    message.ordering !== undefined && (obj.ordering = orderToJSON(message.ordering));
    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? Counterparty.toJSON(message.counterparty) : undefined);
    message.proposedVersion !== undefined && (obj.proposedVersion = message.proposedVersion);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QueryAppVersionRequest>, I>>(object: I): QueryAppVersionRequest {
    const message = createBaseQueryAppVersionRequest();
    message.portId = object.portId ?? \\"\\";
    message.connectionId = object.connectionId ?? \\"\\";
    message.ordering = object.ordering ?? 0;
    message.counterparty = object.counterparty !== undefined && object.counterparty !== null ? Counterparty.fromPartial(object.counterparty) : undefined;
    message.proposedVersion = object.proposedVersion ?? \\"\\";
    return message;
  }

};"
`;

exports[`ibc/core/port/v1/query 2`] = `
Array [
  Object {
    "import": "ibc/core/channel/v1/channel.proto",
    "name": "Counterparty",
    "type": "typeImport",
  },
  Object {
    "import": "ibc/core/channel/v1/channel.proto",
    "name": "Counterparty",
    "type": "typeImport",
  },
  Object {
    "import": "ibc/core/channel/v1/channel.proto",
    "name": "orderFromJSON",
    "type": "fromJSONEnum",
  },
  Object {
    "import": "ibc/core/channel/v1/channel.proto",
    "name": "Counterparty",
    "type": "typeImport",
  },
  Object {
    "import": "ibc/core/channel/v1/channel.proto",
    "name": "orderToJSON",
    "type": "toJSONEnum",
  },
  Object {
    "import": "ibc/core/channel/v1/channel.proto",
    "name": "Counterparty",
    "type": "typeImport",
  },
]
`;

exports[`osmosis/gamm/v1beta1/tx MsgJoinPool 1`] = `
"export const MsgJoinPool = {
  encode(message: MsgJoinPool, writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== \\"\\") {
      writer.uint32(10).string(message.sender);
    }

    if (!message.poolId.isZero()) {
      writer.uint32(16).uint64(message.poolId);
    }

    if (message.shareOutAmount !== \\"\\") {
      writer.uint32(26).string(message.shareOutAmount);
    }

    for (const v of message.tokenInMaxs) {
      Coin.encode(v!, writer.uint32(34).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgJoinPool {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgJoinPool();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;

        case 2:
          message.poolId = (reader.uint64() as Long);
          break;

        case 3:
          message.shareOutAmount = reader.string();
          break;

        case 4:
          message.tokenInMaxs.push(Coin.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): MsgJoinPool {
    return {
      sender: isSet(object.sender) ? String(object.sender) : \\"\\",
      poolId: isSet(object.poolId) ? Long.fromString(object.poolId) : Long.UZERO,
      shareOutAmount: isSet(object.shareOutAmount) ? String(object.shareOutAmount) : \\"\\",
      tokenInMaxs: Array.isArray(object?.tokenInMaxs) ? object.tokenInMaxs.map((e: any) => Coin.fromJSON(e)) : []
    };
  },

  toJSON(message: MsgJoinPool): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);
    message.poolId !== undefined && (obj.poolId = (message.poolId || Long.UZERO).toString());
    message.shareOutAmount !== undefined && (obj.shareOutAmount = message.shareOutAmount);

    if (message.tokenInMaxs) {
      obj.tokenInMaxs = message.tokenInMaxs.map(e => e ? Coin.toJSON(e) : undefined);
    } else {
      obj.tokenInMaxs = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgJoinPool>, I>>(object: I): MsgJoinPool {
    const message = createBaseMsgJoinPool();
    message.sender = object.sender ?? \\"\\";
    message.poolId = object.poolId !== undefined && object.poolId !== null ? Long.fromValue(object.poolId) : Long.UZERO;
    message.shareOutAmount = object.shareOutAmount ?? \\"\\";
    message.tokenInMaxs = object.tokenInMaxs?.map(e => Coin.fromPartial(e)) || [];
    return message;
  }

};"
`;

exports[`osmosis/gamm/v1beta1/tx MsgSwapExactAmountIn 1`] = `
"export const MsgSwapExactAmountIn = {
  encode(message: MsgSwapExactAmountIn, writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== \\"\\") {
      writer.uint32(10).string(message.sender);
    }

    for (const v of message.routes) {
      SwapAmountInRoute.encode(v!, writer.uint32(18).fork()).ldelim();
    }

    if (message.tokenIn !== undefined) {
      Coin.encode(message.tokenIn, writer.uint32(26).fork()).ldelim();
    }

    if (message.tokenOutMinAmount !== \\"\\") {
      writer.uint32(34).string(message.tokenOutMinAmount);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactAmountIn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapExactAmountIn();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;

        case 2:
          message.routes.push(SwapAmountInRoute.decode(reader, reader.uint32()));
          break;

        case 3:
          message.tokenIn = Coin.decode(reader, reader.uint32());
          break;

        case 4:
          message.tokenOutMinAmount = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): MsgSwapExactAmountIn {
    return {
      sender: isSet(object.sender) ? String(object.sender) : \\"\\",
      routes: Array.isArray(object?.routes) ? object.routes.map((e: any) => SwapAmountInRoute.fromJSON(e)) : [],
      tokenIn: isSet(object.tokenIn) ? Coin.fromJSON(object.tokenIn) : undefined,
      tokenOutMinAmount: isSet(object.tokenOutMinAmount) ? String(object.tokenOutMinAmount) : \\"\\"
    };
  },

  toJSON(message: MsgSwapExactAmountIn): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);

    if (message.routes) {
      obj.routes = message.routes.map(e => e ? SwapAmountInRoute.toJSON(e) : undefined);
    } else {
      obj.routes = [];
    }

    message.tokenIn !== undefined && (obj.tokenIn = message.tokenIn ? Coin.toJSON(message.tokenIn) : undefined);
    message.tokenOutMinAmount !== undefined && (obj.tokenOutMinAmount = message.tokenOutMinAmount);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSwapExactAmountIn>, I>>(object: I): MsgSwapExactAmountIn {
    const message = createBaseMsgSwapExactAmountIn();
    message.sender = object.sender ?? \\"\\";
    message.routes = object.routes?.map(e => SwapAmountInRoute.fromPartial(e)) || [];
    message.tokenIn = object.tokenIn !== undefined && object.tokenIn !== null ? Coin.fromPartial(object.tokenIn) : undefined;
    message.tokenOutMinAmount = object.tokenOutMinAmount ?? \\"\\";
    return message;
  }

};"
`;

exports[`osmosis/gamm/v1beta1/tx MsgSwapExactAmountOut 1`] = `
"export const MsgSwapExactAmountOut = {
  encode(message: MsgSwapExactAmountOut, writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== \\"\\") {
      writer.uint32(10).string(message.sender);
    }

    for (const v of message.routes) {
      SwapAmountOutRoute.encode(v!, writer.uint32(18).fork()).ldelim();
    }

    if (message.tokenInMaxAmount !== \\"\\") {
      writer.uint32(26).string(message.tokenInMaxAmount);
    }

    if (message.tokenOut !== undefined) {
      Coin.encode(message.tokenOut, writer.uint32(34).fork()).ldelim();
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSwapExactAmountOut {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSwapExactAmountOut();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.sender = reader.string();
          break;

        case 2:
          message.routes.push(SwapAmountOutRoute.decode(reader, reader.uint32()));
          break;

        case 3:
          message.tokenInMaxAmount = reader.string();
          break;

        case 4:
          message.tokenOut = Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): MsgSwapExactAmountOut {
    return {
      sender: isSet(object.sender) ? String(object.sender) : \\"\\",
      routes: Array.isArray(object?.routes) ? object.routes.map((e: any) => SwapAmountOutRoute.fromJSON(e)) : [],
      tokenInMaxAmount: isSet(object.tokenInMaxAmount) ? String(object.tokenInMaxAmount) : \\"\\",
      tokenOut: isSet(object.tokenOut) ? Coin.fromJSON(object.tokenOut) : undefined
    };
  },

  toJSON(message: MsgSwapExactAmountOut): unknown {
    const obj: any = {};
    message.sender !== undefined && (obj.sender = message.sender);

    if (message.routes) {
      obj.routes = message.routes.map(e => e ? SwapAmountOutRoute.toJSON(e) : undefined);
    } else {
      obj.routes = [];
    }

    message.tokenInMaxAmount !== undefined && (obj.tokenInMaxAmount = message.tokenInMaxAmount);
    message.tokenOut !== undefined && (obj.tokenOut = message.tokenOut ? Coin.toJSON(message.tokenOut) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MsgSwapExactAmountOut>, I>>(object: I): MsgSwapExactAmountOut {
    const message = createBaseMsgSwapExactAmountOut();
    message.sender = object.sender ?? \\"\\";
    message.routes = object.routes?.map(e => SwapAmountOutRoute.fromPartial(e)) || [];
    message.tokenInMaxAmount = object.tokenInMaxAmount ?? \\"\\";
    message.tokenOut = object.tokenOut !== undefined && object.tokenOut !== null ? Coin.fromPartial(object.tokenOut) : undefined;
    return message;
  }

};"
`;
